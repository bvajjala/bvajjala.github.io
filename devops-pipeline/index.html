
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>THE CONTINUOUS DELIVERY TOOLCHAIN - Balaji Vajjala's Blog</title>
  <meta name="author" content="Balaji Vajjala">

  
  <meta name="description" content="The CONTINUOUS DELIVERY TOOLCHAIN Unless your software is very simple, no single tool, automation product, or deployment pipeline implementation &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://bvajjala.github.io/devops-pipeline">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Balaji Vajjala's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  

</head>

<body   class="no-sidebar"  class="collapse-sidebar sidebar-footer" >
  <header role="banner">
	<div class="header-title"><a href="/">Balaji Vajjala's Blog</a></div>


	<br><div class="header-subtitle">A DevOps Blog from Trenches</div>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:bvajjala.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">The CONTINUOUS DELIVERY TOOLCHAIN</h1>
    
  </header>
  
  <p>Unless your software is very simple, no single tool, automation product, or deployment pipeline implementation will provide you with Continuous Delivery. Effective Continuous Delivery requires an organizational understanding of the intent and purposes of the activities you undertake, not merely the automation of those activities.</p>

<p>However, Continuous Delivery is impossible without some core capabilities that tools provide. Each section below will examine a link in the core Continuous Delivery tool chain with examples from each tool category in the boxed sections.</p>

<h2>ORCHESTRATION AND DEPLOYMENT PIPELINE VISUALIZATION</h2>

<p> Orchestration tools are the backbone of any CD system. They allow teams to build an effective sequence of deployment pipeline steps by integrating with their entire tool chain. These tools can also provide visualization utilities, which are important for enabling the full involvement of stakeholders from all departments.
For pipeline orchestration and visualization, you can use a dedicated deployment pipeline tool or you can use an application release automation (ARA) solution. Whichever direction you take for your orchestration tool, you should be sure that it helps your team detect and expose delays at each stage of the pipeline, including wait times between stages. Visualization and orchestration working in tandem allow teams to quickly identify the places they should optimize first.</p>

<table>
<thead>
<tr>
<th></th>
<th>Dedicated Deployment pipeline Tools</th>
<th>Jenkins, Travis CI, ThoughtWorks GO, CircleCI, JetBrains TeamCity, Atlassian Bamboo</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>APPLICATION RELEASE AUTOMATION (ARA)</td>
<td>ElectricCommander, CA LISA, IBM UrbanCode, XebiaLabs XL|</td>
</tr>
<tr>
<td></td>
<td>Orchestration Engine</td>
<td>MaestroDev, CollabNet|</td>
</tr>
</tbody>
</table>


<h2>VERSION CONTROL</h2>

<p>Most software development teams use a version control system for the files they consider source code. However, many organizations forget to include configuration files, such as the configuration that defines the build and release system. All text-based assets should be stored in  a version control system that everyone can easily access. The code changes should be very easy to review, line-by-line (ideally in a web browser), with a pull or merge request.</p>

<figure class='code'><figcaption><span>linenos:false </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Version Control:  Git, Mercurial, Perforce, Subversion, TFS</span></code></pre></td></tr></table></div></figure>


<h2>CONTINUOUS INTEGRATION</h2>

<p>CI tools can support orchestration and visualization, but their core functionality is to integrate new code with the stable main release line and alert stakeholders if any new code would cause issues with the final product. This makes it easy for teams to combine work on different features while keeping a master code branch ready for release. It should feel natural to integrate many times a day. Teams should also connect a code metrics and profiling utility that can stop integrations if certain metrics reach an undesirable threshold.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CI:  Jenkins, Travis CI, ThoughtWorks GO, CircleCI, JetBrains TeamCity, Atlassian Bamboo
</span><span class='line'>Code Metrics:  SonarQube, SLOC (and variants), SciTools Understand</span></code></pre></td></tr></table></div></figure>


<h2>ARTIFACT MANAGEMENT</h2>

<p>Packaged artifacts, rather than the application’s raw source code, are the focus of deployment pipelines. Artifacts are assembled pieces of an application that include packaged application code, application assets, infrastructure code, virtual machine images, and (typically) configuration data. Artifacts are identifiable (unique name), versioned (preferably semantic versioning), and immutable (we never edit them). Together, these artifacts allow developers to build a bill of materials (BOM) package describing the exact versions of all the artifacts in a particular version of their software system. Package metadata identifies when and how the package was tested or deployed into a particular environment.</p>

<p>Artifact management is most effective with an artifact repository manager. Artifact repositories contain a complete artifact usage history,  similar to the way version control systems track source code changes. They use dependency resolution between the package versions and allow the system to build a dependency graph from the hardware all the way up to the user interface of the application. The ability to verify dependencies through an entire system is powerful for tracking exactly what was (or will be) tested or deployed.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Version Control Systems: Git, Subversion, Mercurial
</span><span class='line'>
</span><span class='line'>Artifact Repository Managers: Archiva, Artifactory, Nexus (roll-your-own with zip files, metadata, shared storage, and access controls) Language-specific package Managers: Composer (PHP), Ruby Gems, npm (Node.js), Python PIP
</span><span class='line'>
</span><span class='line'>OrchestrationOS-level package Managers: APT, Chocolatey, RPM</span></code></pre></td></tr></table></div></figure>


<h2>TEST AND ENVIRONMENT AUTOMATION</h2>

<p>The only manual testing in a deployment pipeline should be for tests that are tough for a computer to handle, such as exploratory testing, inspection of user interface designs, and user acceptance tests. The rest should be automated. Tools for automated testing should operate in a completely headless (non-interactive) manner and be lightweight enough to run across many test servers simultaneously. Teams also need to create testing environments on-demand by using environment automation tools that can provision a vm and configure an environment template.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Test Automation: JMeter, Selenium/WebDriver, Cucumber (BDD), RSpec (BDD), SpecFlow (BDD), LoadUI (Performance), PageSpeed (Performance), Netem(Network Emulation), SoapUI (Web Services), Test Kitchen (Infrastructure)
</span><span class='line'>
</span><span class='line'>Environment Automation:  Vagrant, Docker, Packer</span></code></pre></td></tr></table></div></figure>


<h2>SERVER CONFIGURATION AND DEPLOYMENT</h2>

<p>Current deployment tools support three models:
* push model:  manages the distribution and installation of packages to multiple remote machines. It’s a good choice for smaller systems because it’s usually simple and quick.
* pull model:  Requires an infrastructure configuration tool such as Chef or Puppet. Supporters say it scales better than push and like that it treats the deployment of application code as another step in configuring the infrastructure.
*  hybrid model:  Uses a push tool to trigger a pull client on target servers.</p>

<p>For any of the three models, your team must ensure that the process is fully automated, provides detailed information with standard output and error messages, and allows easy and rapid rollback to a stable state.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>push deployment:  Capistrano, Fabric, ThoughtWorks Go, MSdeploy, Octopus, RunDeck, various CI and build tools, various ARA tools 
</span><span class='line'>pull deployment:  Ansible, Chef, CFEngine, Puppet, Salt.</span></code></pre></td></tr></table></div></figure>


<h2>MONITORING AND REPORTING</h2>

<p>Monitoring your system logs is essential for spotting problems and halting the deployment pipeline. Rather than manually collecting logs from each machine in an environment, logs should be shipped to a central store that indexes them and makes them available for searching via a web browser.
This is a crucial capability for a Continuous Delivery environment. The log store should be connected to all environments (including the developer’s system) to speed up problem diagnosis and resolution. most monitoring tools should work in a dynamic infrastructure and integrate with yours through scripted configuration.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Log Aggregation & Search: Fluentd, Graylog2, LogStash, nxlog, Splunk 
</span><span class='line'>Metrics, Monitoring, Audit: Collectd, Ganglia, Graphite, Icinga, Sensu, ScriptRock</span></code></pre></td></tr></table></div></figure>


<h2>A FINAL LOOK AT SOME GUIDING PRINCIPLES FOR TOOLS</h2>

<p> It’s important to understand all the capabilities your team needs before selecting the tools to build your Continuous Delivery system. The following list details the key areas you should always keep in mind when selecting tools:</p>

<ul>
<li>Visibility: look for tools that have clear, comprehensive visualizations for everything that your organization needs to track.</li>
<li>Traceability: Select tools that will allow you to easily track important metadata from your source code, infrastructure code, binary artifacts, application and infrastructure configuration, vm images, and the deployment pipeline configuration.</li>
<li>Full Coverage: Tools must cover all of the applicable environments in order for delivery to be consistent. If a tool is too expensive to have in every environment, you shouldn’t choose it.</li>
</ul>


<p>In addition to these tool selection suggestions, you should consider using separate tools for CI and visualization/ orchestration, because these capabilities have different requirements.</p>

<p>You should also ensure that versioned, traceable artifacts are the key unit of currency for the deployment pipeline. Avoid simplistic linear sequential pipeline stages where parallel flows would better meet business needs.</p>

<p>Finally, insist on a system that tracks, measures, and visualizes the flow of artifacts toward production so that all stakeholders can effectively engage with your software production process.</p>

<p>Insist on a system that tracks, measures, and visualizes the flow of artifacts toward production so that all stakeholders can effectively engage with your software production process.</p>

<h2>W R I T T E N  BY Balaji Vajjala</h2>

<p>Balaji Vajjala is an independent software consultant who helps organizations to design and operate effective software delivery practices, with a focus on the re-design and evolution of software in order to support Continuous Delivery.
He initiated and helped to run PIPELINE, the first conference in Mid West dedicated to Continuous Delivery, having co-founded and organised the Indy Continuous Delivery meetup group since 2012.</p>

<p>He is writing two books: one on package management in a Windows environment, and one on software operability.</p>

  
    <footer>
      
      
    </footer>
  
</article>

</div>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  Balaji Vajjala <br/>
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> + <a href="https://github.com/ioveracker/mnml">mnml</a>.
	  
  </span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
